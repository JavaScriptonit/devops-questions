## Вопросы:
1. Какие объекты создаёт terraform? Где лучше всего хранить terraform? Как лучше всего делить созданные объекты в terraform? Единый стейт или Terragrunt в каких случаях используется?
2. Где хранить .tfstate? 
3. Что делать если произошло изменение файла состояния (.tfstate) вручную? 
4. Настраивал ли RBAC внутри? ec2? subnet? vpc?
5. Что такое модуль Terraform?
6. Что такое state Terraform и где его лучше хранить?
7. Что будет если 2 разработчика обновят файл .tfstate одновременно? (Terraform)
8. Есть ли отличия в синтаксисе провайдеров для Terraform при написание файлов? (Terraform)
9. Как избежать ситуации чтобы 1 ресурс не изменили одновременно 2 разных человека и не перетёрли изменения друг друга? (Terraform)
10. 

## 1. Какие объекты создаёт terraform? Где лучше всего хранить terraform? Как лучше всего делить созданные объекты в terraform? Единый стейт или Terragrunt в каких случаях используется? (Terraform)

1. **Определение инфраструктуры:** На языке конфигурации Terraform (HCL) описывается желаемое состояние инфраструктуры, включая виртуальные машины, сети, хранилища и другие ресурсы.

2. **Инициализация:** Terraform инициализируется для загрузки необходимых провайдеров и модулей, указанных в конфигурации.

3. **Планирование:** Terraform генерирует план изменений, которые будут применены к текущей инфраструктуре для достижения желаемого состояния.

4. **Применение:** После проверки плана изменений, Terraform применяет их, создавая, изменяя или удаляя ресурсы в облаке или локальной инфраструктуре.

При работе с `Terraform` обычно используются модули, переменные и state файлы для организации и управления конфигурацией. Модули позволяют организовать конфигурацию на более мелкие и переиспользуемые блоки, переменные используются для передачи значений в конфигурацию, а **state файл хранит текущее состояние инфраструктуры**.

`Terragrunt` - это дополнительный инструмент, который облегчает управление конфигурациями Terraform, особенно при работе с крупными проектами. Terragrunt предоставляет дополнительные функции, такие как управление переменными, блокировка состояния и использование модулей Terraform.

Terraform создает различные объекты в облаке или локальной инфраструктуре в соответствии с описанными в конфигурации ресурсами. Некоторые из типичных объектов, которые Terraform может создать, включают виртуальные машины, сетевые ресурсы (например, сети, подсети, балансировщики нагрузки), хранилища данных (например, базы данных, объектные хранилища), и многое другое.

### Что касается хранения Terraform конфигурации и состояния, рекомендуется использовать следующие подходы:

1. **Хранение конфигурации:** Terraform конфигурационные файлы лучше всего хранить в системе контроля версий, таком как Git. Это обеспечивает версионирование, аудит и совместную работу над конфигурацией.

2. **Хранение состояния:** Состояние Terraform, которое отслеживает текущее состояние инфраструктуры, должно быть храниться в безопасном и надежном месте. Рекомендуется использовать удаленное хранилище состояния, такое как Terraform Cloud, AWS S3, Azure Blob Storage и т. д.

Что касается деления созданных объектов в Terraform, хорошей практикой является использование модулей для организации и переиспользования конфигурации. Модули позволяют разделить инфраструктурные ресурсы на логические блоки, что упрощает управление и поддержку конфигурации.

### Относительно использования единого состояния Terraform против Terragrunt, обычно Terragrunt используется в следующих случаях:

- Когда требуется управление переменными и конфигурациями на разных уровнях (например, на уровне окружений).
- Когда необходима более гибкая организация конфигураций и модулей Terraform.
- При работе с крупными проектами, где требуется более сложное управление состоянием и конфигурациями.

Таким образом, Terraform создает различные объекты инфраструктуры, конфигурационные файлы лучше всего хранить в системе контроля версий, состояние - в удаленном хранилище, объекты можно лучше всего делить на модули, и Terragrunt используется в случаях, когда требуется более сложное управление конфигурациями и состоянием Terraform.

## 2. Где хранить .tfstate? (Terraform)

https://cloud.yandex.ru/ru/docs/tutorials/infrastructure-management/terraform-state-storage#bash_1 - Загрузка состояний Terraform в Yandex Object Storage

Хранение файла состояния (.tfstate) в системе контроля версий, такой как GitLab или GitHub, не является рекомендуемой практикой. Файл состояния Terraform содержит чувствительную информацию о текущем состоянии инфраструктуры, и его изменения могут быть критическими для безопасности и целостности инфраструктуры.

Рекомендуется хранить файл состояния в безопасном и надежном удаленном хранилище, таком как AWS S3, Azure Blob Storage, Google Cloud Storage или Terraform Cloud. Это обеспечивает централизованное управление состоянием, защиту от потери данных и возможность совместной работы над инфраструктурой.

Если файл состояния будет храниться в системе контроля версий, это может привести к проблемам с конкурентным доступом, возможными конфликтами при слиянии изменений и уязвимостям безопасности. Поэтому для хранения .tfstate рекомендуется использовать специализированные инструменты и сервисы, предназначенные для управления состоянием Terraform.

```
terraform {
  required_providers {
    yandex = {
      source = "yandex-cloud/yandex"
    }
  }

  backend "s3" {
    endpoints = {
      s3 = "https://storage.yandexcloud.net"
    }
    bucket = "<имя_бакета>"
    region = "ru-central1"
    key    = "<путь_к_файлу_состояния_в_бакете>/<имя_файла_состояния>.tfstate"

    skip_region_validation      = true
    skip_credentials_validation = true
    skip_requesting_account_id  = true # Необходимая опция Terraform для версии 1.6.1 и старше.
    skip_s3_checksum            = true # Необходимая опция при описании бэкенда для Terraform версии 1.6.3 и старше.

  }
}

provider "yandex" {
  zone      = "<зона_доступности_по_умолчанию>"
}
```

## 3. Что делать если произошло изменение файла состояния (.tfstate) вручную? (Terraform)

Изменение файла состояния (.tfstate) вручную не рекомендуется, так как это может привести к несоответствиям между фактическим состоянием инфраструктуры и содержимым файла состояния. Это может вызвать ошибки развертывания, потерю данных или другие проблемы.

Если в файл состояния был внесен код вручную, то рекомендуется принять следующие шаги:

1. **Откат изменений:** Попробуйте откатить изменения в файле состояния до предыдущего рабочего состояния, если это возможно. Это можно сделать, например, через систему контроля версий, если у вас есть сохраненные версии файла состояния.

2. **Восстановление из резервной копии:** Если у вас есть резервные копии файла состояния, попробуйте восстановить состояние из последней рабочей резервной копии.

3. **Пересоздание ресурсов:** Если не удается восстановить файл состояния, возможно придется пересоздать ресурсы, описанные в файле состояния. Это может быть времязатратным процессом, но иногда это единственный способ восстановить целостность инфраструктуры.

Для предотвращения подобных ситуаций и обеспечения безопасной работы с файлом состояния (.tfstate) рекомендуется следовать следующим best practices:

1. **Используйте удаленное хранилище состояния:** Храните файл состояния в удаленном и безопасном хранилище, таком как AWS S3, Azure Blob Storage или Terraform Cloud. Это обеспечивает централизованное управление состоянием и защиту от потери данных.

2. **Не изменяйте файл состояния вручную:** Избегайте внесения изменений в файл состояния вручную, используйте Terraform для управления состоянием и инфраструктурой.

3. **Регулярно создавайте резервные копии:** Регулярно создавайте резервные копии файла состояния, чтобы иметь возможность восстановиться в случае необходимости.

### Если в файле состояния (.tfstate) были внесены изменения вручную, то:
Рекомендуется исправить это с помощью Terraform, а именно через использование команды `terraform import`.

Команда `terraform import` позволяет импортировать существующий ресурс в управляемый Terraform состоянием. Это позволит Terraform узнать о существующем ресурсе и начать управлять им, не изменяя его текущего состояния.

Изменение файла состояния (.tfstate) напрямую не рекомендуется, так как это может привести к несоответствиям между фактическим состоянием инфраструктуры и содержимым файла состояния, что может вызвать проблемы при развертывании и управлении инфраструктурой.

Поэтому, если были внесены изменения в файл состояния вручную, рекомендуется использовать команду `terraform import` для корректного импорта существующего ресурса в Terraform и обновления состояния.

## 4. Настраивал ли RBAC внутри? ec2? subnet? vpc?

Terraform модуль для создания RBAC-правил - https://habr.com/ru/companies/nixys/articles/649663/
```
Управление доступом на основе ролей (англ. Role Based Access Control, RBAC) 
Начиная с Kubernetes 1.6, RBAC-политики включены по умолчанию
Раньше нам приходилось вручную создавать подобные политики, сервисные аккаунты и пользователей

Данный модуль позволяет создавать сервисные аккаунты и пользователей, а затем генерировать готовые конфигурационные файлы (kubeconfig) для них
Также при помощи данного модуля можно создавать роли, кластерные роли и привязывать их к определенным сервисным аккаунтам, пользователям или группам.
Модуль можно найти в нашем GitHub репозитории - https://github.com/nixys/nxs-k8s-rbac-creator

В этом примере создается роль role-1 в default окружении со следующими правами:
apiVersion: rbac.authorization.k8s.io/v1
kind: Role

Также создается кластерная роль cluster-role-1 со следующими правами:
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole

и cluster-role-2 со следующими правами:
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole

Дополнительно создаются сервисные аккаунты sa-1 в окружении kube-system и sa-2 в окружении default.
Список пользователей для создания берется из поля users в переменной bindings.
То есть в данном случае будут созданы 2 пользователя user-1 и user-2 в группах group-1 и group-2 соответственно.
Также будут созданы 2 RoleBinding cluster-role-2-prefix-1-cluster-role:
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding

и role-1-prefix-1-role следующего вида:
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding

Также будет создан ClusterRoleBinding (соответствует количеству элементов в списке cluster_roles, если type = cluster_role_binding) cluster-role-1-prefix-2:
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding


Данный модуль помог повысить нашу эффективность. Раньше мы могли тратить от 20 до 60 минут на создание RBAC политик. Сейчас же на это уходит от 5 до 10 минут. 
Как правило для проектов мы используем одни и те же роли и кластерные роли. 
То есть можно повторно использовать зараннее созданные файлы с заполненными переменными.
```

K8s инфра в Terraform:
```
https://habr.com/ru/companies/nixys/articles/721404/
Решение — разбиваем конфигурационные файлы по типу описываемых компонентов, т. е. есть главный файл main.tf, где мы объявим провайдера и пропишем доступы к облаку. 

my_project/
├── k8s
│   ├── cluster.tf
│   ├── main.tf
│   ├── node_group.tf
│   ├── service_account.tf
└── network
    ├── external_ip.tf
    ├── main.tf
    ├── security_group.tf
    └── vpc.tf
```

## 5. Что такое модуль Terraform?

1 мая 2023 г. Модули Terraform — это готовые наборы файлов с настройками для облачных сервисов, которые упрощают работу DevOps-инженеров. Также модули помогают избегать дублирования кода. Модули Terraform для сервисов Yandex Cloud уже доступны на GitHub.

## 6. Что такое state Terraform и где его лучше хранить?

Состояние Terraform описывает текущую развернутую инфраструктуру и хранится в файлах с расширением . tfstate . Файл состояния создается после развертывания инфраструктуры и может быть сразу загружен в Object Storage. Загруженный файл состояния будет обновляться после изменений созданной инфраструктуры.

Этот файл используется для отслеживания метаданных и для сопоставления фактических ресурсов с конфигурацией.

По умолчанию этот файл состояния будет находиться локально в папке ваших проектов с именем terraform.tfstate.

Рекомендуется хранить состояния Terraform в высокодоступном удаленном хранилище данных, например, Terraform Cloud, HashiCorp Consul, Amazon S3, Google Cloud Storage (GCS):

```
# Backend
#terraform {
#  backend "local" {
#    path = "terraform.tfstate"
#  }
#}

terraform {
  backend "consul" {
    address  = "consul.example.com:8500"
    scheme   = "http"
    path     = "tf/terraform.tfstate"
    lock     = true
    gzip     = false
  }
}
```

## 7. Что будет если 2 разработчика обновят файл .tfstate одновременно? (Terraform)

https://ru.hexlet.io/courses/terraform-basics/lessons/remote-state/theory_unit

`Terraform` хранит текущее состояние инфраструктуры в файле с расширением `.tfstate`. При выполнении операций `Terraform` идет в файл состояния и проверяет, какая инфраструктура уже развернута. На основе того, что есть в состоянии и что описано в проекте, `Terraform` понимает, что нужно сделать — создать инфраструктуру или изменить.

Если организовать этот процесс через `git-репозиторий`, нужно сначала обновить инфраструктуру, затем добавить коммит с новым `tfstate` и отправить его в удаленный репозиторий. Коллега должен получить из репозитория актуальный `tfstate`, внести свои изменения, и в свою очередь отправить изменения в коде `Terraform` и новый файл состояния в `Git`

### `Terraform remote backends`:

В терминологии Terraform backend — это решение, которое отвечает за хранение состояния. Если состояние хранится удаленно — это `remote backend`.

При использовании remote backend Terraform сохраняет состояние в удаленное хранилище, а локально в tfstate хранит только информацию об этом удаленном хранилище.

В качестве хранилища может выступать любое облачное объектное хранилище по типу `Amazon S3: Google Cloud Storage`, `Azure Storage`, `Yandex Cloud Storage` и другие подобные решения. Также Terraform может использовать для удаленного хранения состояния HTTP-сервер, базу данных PostgreSQL или облачную платформу Terraform Cloud.

В схеме с remote backend при выполнении любых операций над инфраструктурой Terraform будет обращаться к удаленному файлу состояния, блокировать его на время выполнения изменений, затем перезаписывать этот файл с учетом внесенных изменений

#### Как настроить хранение состояния в S3:
Подготавливаем облако для хранения состояния (Создадим в облаке S3-хранилище yc-hexlet-state объемом 10МБ. Этого хватит для хранения состояния надолго):
```
yc storage bucket create --name yc-hexlet-state --max-size 10000000
```
сделать табличку в облачной базе данных, где Terraform будет фиксировать блокировки состояния:
```
yc ydb database create terraform-state-lock --serverless

done (7s)
id: etnpkn3gs4s56qk9g7kf
folder_id: ...
created_at: ...
name: terraform-state-lock
...
document_api_endpoint: https://docapi.serverless.yandexcloud.net/ru-central1/b1gjrod3dvqni46u3paj/etnpkn3gs4s56qk9g7kf
```
Сохраним document_api_endpoint, он нам понадобится при конфигурации Terraform («Создать таблицу» и создадим документную таблицу lock с колонкой LockID типа String, которая будет являться ключом партиционирования)

через YandexCLI создадим сервисный аккаунт hexlet-remote, который будет сохранять состояние Terraform в облачное хранилище
```
yc iam service-account create --name hexlet-remote --description "SA to manage terraform state"

id: ajejk11p9ls1vvhc12mb
folder_id: ...
created_at: ...
name: hexlet-remote
description: SA to manage terraform state
```

Создадим в проекте файл backend.tf и вставим туда блок backend, описывающий хранение состояния:
```
terraform {
  backend "s3" {
    endpoint                    = "storage.yandexcloud.net"
    region                      = "ru-central1"
    bucket                      = "yc-hexlet-state"
    key                         = "hexlet-remote-state"
    access_key                  = "YCABX6vQXtCjoKu_oB7QabuZO"
    secret_key                  = "YCOL4xZ1tdpduS46z_YTlvDzYUwv8xBK_UuRq18m"
    dynamodb_endpoint           = "https://docapi.serverless.yandexcloud.net/ru-central1/b1gjrod3dvqni46u3paj/etnpkn3gs4s56qk9g7kf"
    dynamodb_table              = "lock"
    skip_region_validation      = true
    skip_credentials_validation = true
  }
}
```
Перенести локальный файл с состоянием в удаленное хранилище:
```
terraform init -migrate-state
```

Так мы с помощью удаленного хранения состояния в S3-хранилище и блокировки состояния в YDB добились того, что:

Состояние инфраструктуры всегда будет одинаковым и актуальным у всей команды. Локально в .tfstate проекта будет храниться только адрес удаленного бэкенда
Не возникнут конфликты одновременного обновления инфраструктуры двумя или более членами команды
Мы настроили удаленное хранение состояния. Осталось позаботиться о безопасности и о том, чтобы ключи для нашего хранилища не утекли в сеть.

## 8. Есть ли отличия в синтаксисе провайдеров для Terraform при написание файлов? (Terraform)
Есть различия в синтаксисе провайдеров для Terraform при написании файлов конфигурации. 
Каждый провайдер имеет свои уникальные параметры и настройки, которые могут отличаться от других провайдеров. 
Например, у провайдера `AWS` могут быть свои уникальные параметры, отличающиеся от параметров провайдера `Google Cloud Platform`.

Кроме того, различные провайдеры могут поддерживать разные версии API и иметь разные способы авторизации и настройки доступа. 
Все это может отразиться на синтаксисе и структуре файлов конфигурации Terraform для каждого провайдера.

Поэтому при написании файлов конфигурации Terraform для различных провайдеров важно обращать внимание на документацию каждого провайдера и учитывать их уникальные особенности.

Пример `простого ресурса` `AWS S3` и аналогичного ресурса `Digital Ocean Spaces` в файле конфигурации Terraform:
```
# AWS S3
resource "aws_s3_bucket" "example" {
  bucket = "my-unique-bucket"
  acl    = "private"
}

# Digital Ocean Spaces
resource "digitalocean_spaces_bucket" "example" {
  name   = "my-unique-bucket"
  region = "nyc3"
  acl    = "private"
}
```
В этом примере видно, что параметры для создания бакета в облаке AWS S3 и Digital Ocean Spaces имеют некоторые различия. 
Например, у Digital Ocean Spaces есть параметр `region`, который отсутствует у AWS S3, зато у AWS S3 есть параметр `bucket`, который является обязательным. Также, у обоих провайдеров есть параметр `acl`, который задает права доступа к бакету, но возможно у них различные допустимые значения.

`bucket` - это обозначение хранилища (или контейнера) файлов в облаке. В случае AWS S3 и Digital Ocean Spaces, "bucket" представляет собой хранилище для файлов, к которому можно обращаться через API или веб-интерфейс.

`Простой ресурс` в Terraform представляет собой объект, который хотите создать или управлять в облаке (например, виртуальная машина, база данных, хранилище файлов и т. д.). "aws_s3_bucket" и "digitalocean_spaces_bucket" - это ресурсы, представляющие собой хранилища файлов в облаке AWS и Digital Ocean.

## 9. Как избежать ситуации чтобы 1 ресурс не изменили одновременно 2 разных человека и не перетёрли изменения друг друга? (Terraform)
Для избежания ситуации, когда два разных человека изменяют один и тот же ресурс в Terraform одновременно и могут перетереть изменения друг друга, можно использовать следующие рекомендации:

1. Разделение областей ответственности: разделите ресурсы между членами команды таким образом, чтобы каждый член команды был ответственен за определенные ресурсы. Это позволит избежать конфликтов при одновременном изменении одних и тех же ресурсов.

2. Использование блокировок: Terraform Enterprise и Terraform Cloud предоставляют возможность использования блокировок, которые предотвращают одновременное изменение одного и того же ресурса несколькими пользователями. Если вы используете Terraform в облаке, вы можете воспользоваться этой функцией.

3. Использование системы контроля версий: Используйте систему контроля версий, такую как Git, для управления вашими конфигурационными файлами Terraform. При этом важно следить за обновлениями и конфликтами при слиянии изменений.
Ревью изменений: Перед применением изменений с помощью Terraform, можно устроить ревью изменений, чтобы убедиться, что они не конфликтуют друг с другом и не приведут к нежелательным последствиям.

4. Коммуникация и согласование: Убедитесь, что у вашей команды есть хорошая коммуникация и согласование при работе с Terraform. Это позволит избежать конфликтов и перетирания изменений.

