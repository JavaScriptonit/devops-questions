## Вопросы:
1. Что такое CGroups?
2. Расскажи про сигналы в Linux. 
3. Какие бывают виды сигналов в Linux? 
4. Назвать все команды из 2ух букв.
5. Что такое код выхода и какие знаешь?
6. Виртуалка. df -h /home/user1 показывает примонтированный диск на 10Гб из которых 5Гб занято. При создании файла - Ошибка: "No space left on device". Что это может быть?
7. Что такое procfs?
8. Описание файлов и директории из ProcFS.
9. Что такое "strace"?
10. Какая технология лежит в основе всей контейнеризации в Linux? (Linux)
11. Какие namespaces бывают? (Linux)
12. Нужно зайти на сервер и посмотреть потребление ресурсов. Процессор/Память/Диск/Сеть. Какими командами? (Linux)
13. Чем отличается системное от пользовательского времени (процессорное)? (Linux)
14. В Allure-server - ошибка: "No space left on device" и путь. df -h показывает что место есть. В чем проблема? (Linux)
15. Как потюнить Файловую систему? Какой командой её можно улучшить? (Linux)
16. Как поднять приоритет выполнения процесса на процессоре? (Linux)
17. Символические ссылки и жесткие ссылки. В чем разница? (Linux)
18. Как ограничить процесс по потребляемой оперативной памяти? (Linux)
19. У нас есть директория, у неё права 755. Что это обозначает? (Linux)
20. Что означает "Выполнение" для директории? (Linux)
21. У нас есть директория, у неё права 700. Нужно не меняя владельца и права добавить доступ кому-то для работы с этой директорией. Как это сделать? (Linux)
22. AppArmor и SELinux профиль. Приходилось ли дебажить и настраивать? (Linux)
23. Cgroups изолируют ресурсы для контейнеров. Какая еще технология используется для контейнеризации? Ресурсы мы изолировали, но какая технология отвечает за процессы, которые мы видим в контейнерах? (Linux)
24. 

## 1. Что такое CGroups? (Linux)

`Cgroups (control groups)` - это технология для управления и ограничения ресурсов, таких как CPU, память, сеть и другие, для группы процессов. Она не является частью namespaces, но часто используется вместе с ними для создания и управления контейнерами.

## 2. Расскажи про сигналы в Linux. (Linux)

В Linux сигналы - это механизм, который используется для управления процессами. Сигналы могут быть отправлены процессу для уведомления о различных событиях или для управления его поведением.

Два из наиболее часто используемых сигналов в Linux:

1. SIGKILL (сигнал 9): Этот сигнал используется для немедленного завершения процесса. Процесс не имеет возможности обработать или игнорировать SIGKILL. Этот сигнал обычно используется для принудительного завершения процесса в случае критической ошибки.

Пример команды для отправки SIGKILL процессу с определенным PID (например, PID=1234):
```bash
kill -9 1234
```

2. SIGTERM (сигнал 15): Этот сигнал также используется для завершения процесса, но он более "мягкий" по сравнению с SIGKILL. Процесс имеет возможность обработать SIGTERM и выполнить необходимые действия перед завершением. Этот сигнал часто используется для грациозного завершения процесса.

Пример команды для отправки SIGTERM процессу с определенным PID (например, PID=1234):
```bash
kill -15 1234
```

Сигналы в Linux используются для различных целей, таких как управление процессами, обработка ошибок, перезагрузка сервисов и другие операции. Правильное использование сигналов помогает в управлении процессами и решении различных задач в операционной системе.

## 3. Какие бывают виды сигналов в Linux? (Linux)

В Linux существует много различных сигналов, каждый из которых имеет свою уникальную функцию. Некоторые из наиболее важных и часто используемых сигналов включают в себя:

1. **SIGINT (сигнал 2)**: Используется для прерывания (interrupt) процесса, обычно посылается при нажатии комбинации клавиш Ctrl+C.

2. **SIGTERM (сигнал 15)**: Уведомляет процесс о необходимости завершения. Часто используется для грациозного завершения процесса.

3. **SIGKILL (сигнал 9)**: Принудительно завершает процесс без возможности обработки сигнала. Обычно используется в критических ситуациях.

4. **SIGHUP (сигнал 1)**: Посылается процессу при отключении терминала или при перезапуске демона.

5. **SIGUSR1 (сигнал 10)** и **SIGUSR2 (сигнал 12)**: Пользовательские сигналы, которые могут использоваться для специфических задач в приложениях.

Всего в Linux существует более 30 различных сигналов. Каждый сигнал имеет свой уникальный номер и назначение. Некоторые сигналы могут быть перехвачены и обработаны программами, в то время как другие приводят к немедленному завершению процесса. Корректное использование сигналов важно для управления процессами и обеспечения стабильной работы системы.

## 4. Назвать все команды из 2ух букв.
```
ls, ps, cd, mw, rm, ln, lp, df, du, fg, ip, su, vi, cp, mc
```

## 5. Что такое код выхода и какие знаешь?
```
1	разнообразные ошибки
2	согласно документации к Bash -- неверное использование встроенных команд
126	вызываемая команда не может быть выполнена
127	"команда не найдена"
128	неверный аргумент команды exit
128+n	фатальная ошибка по сигналу "n"
130	завершение по Control-C
255*	код завершения вне допустимого диапазона
```

## 6. Виртуалка. df -h /home/user1 показывает примонтированный диск на 10Гб из которых 5Гб занято. При создании файла - Ошибка: "No space left on device". Что это может быть?
    1. Ребут: `sudo reboot`
    2. Проверка mount /etc/fstab: `sudo mount -a`
    3. Проверить symbolic link and hard link: `ls -l`
        1. `find . -type l` - найти линки
        2. `readlink имя_символической_ссылки` -  узнать, на что указывает символическая ссылка
    4. Проверить кол-во свободных inodes: `df -T`
    Ответ: Проблема была из-за отсутствия свободных inodes на диске. 2 решения: добавить памяти на диск для увеличения кол-ва инод или изменить файловую систему.

## 7. Что такое procfs?
    1. `ProcFS` — специальная файловая система, используемая в Linux, позволяет получить доступ к информации из ядра о системных процессах.
    2. `ps -ef` - выведет список всех запущенных на данный момент процессов:
    ```
    UID        PID  PPID  C STIME TTY          TIME CMD
    root         1     0  0 11:08 ?        00:00:04 init
    root         2     1  0 11:08 ?        00:00:00 [keventd]
    mbutcher  1219  1207  0 12:23 pty/s2   00:00:00 /bin/bash
    root         8     1  0 11:08 ?        00:00:00 [kjournald]
    ```

## 8. Описание файлов и директории из ProcFS.
```
/proc/PID/cmdline – аргументы командной строки (где PID – идентификатор процесса или self);
/proc/PID/environ – переменные окружения для данного процесса;
/proc/PID/status – статус процесса;
/proc/PID/fd – директория, содержащая символьные ссылки на каждый открытый файловый дескриптор;
/proc/cpuinfo – информация о процессоре (производитель, модель, поколение и т.п.);
/proc/cmdline – параметры, передаваемые ядру при загрузке;
/proc/uptime – количество секунд, прошедших с момента загрузки ядра и проведенных в режиме бездействия;
/proc/version – содержит информацию о версии ядра, компилятора и другую информацию, связанную с загруженным ядром.
/proc/sys/fs/file-max - показывает предел Max Open File Limit (обозначающий число одновременно открытых файлов)
/proc/sys/fs/file-nr - по порядку параметр выдает три значения: число открытых в данный момент файлов; число открытых, но не используемых файлов; максимальное число открытых файлов
```

## 9. Что такое "strace"?
    1. Утилита strace предназначена для отслеживания системных вызовов, которые выполняются процессом в операционной системе Linux. Она позволяет наблюдать взаимодействие между процессом и операционной системой, отслеживая системные вызовы, сигналы, чтение и запись файлов, а также другие операции ввода-вывода.
        1. `strace -p <PID>` - где <PID> - идентификатор процесса, который вы хотите отследить.

## 10. Какая технология лежит в основе всей контейнеризации в Linux? (Linux)

В основе контейнеризации в Linux лежит технология `Linux-контейнеров (LXC)`, которая представляет собой механизм изоляции процессов и ресурсов внутри операционной системы Linux. LXC позволяет создавать и управлять контейнерами, которые являются легковесными виртуальными средами, изолированными друг от друга и от хост-системы.

Однако, следует отметить, что LXC представляет более `низкоуровневый подход к контейнеризации`, и его использование напрямую может потребовать дополнительных инструментов и управления. В более современных подходах к контейнеризации, таких как Docker, используется более высокоуровневый интерфейс для управления контейнерами, который упрощает их создание, управление и развертывание.

Таким образом, хотя LXC является основой контейнеризации в Linux, для более удобного и гибкого использования контейнеров часто применяются более высокоуровневые инструменты, такие как Docker, Kubernetes и т.д.

-----------------------

В основе контейнеризации в Linux лежат две основные технологии: `cgroups (control groups)` и `namespaces`.

`Cgroups` позволяют ограничивать и изолировать потребление ресурсов, таких как CPU, память, сетевые ресурсы и другие, для процессов внутри контейнера. Это обеспечивает контроль над ресурсами, используемыми контейнером, и предотвращает переполнение или конфликты ресурсов между контейнерами и хост-системой.

`Namespaces` обеспечивают изоляцию различных аспектов операционной системы для процессов внутри контейнера. Например, с помощью namespaces можно изолировать файловую систему, сетевое пространство и другие системные ресурсы, чтобы контейнер видел только свою собственную "виртуальную" версию этих ресурсов.

Используя cgroups и namespaces, Linux обеспечивает основу для контейнеризации, а инструменты, такие как Docker, используют эти технологии для удобного управления контейнерами. Благодаря этим технологиям контейнеризация стала широко распространенным и эффективным методом изоляции и управления приложениями в современных системах.

-----------------------

Пример использования cgroups:
```
# Создание cgroup для ограничения использования памяти
sudo cgcreate -g memory:mygroup
# Ограничение использования памяти контейнером в cgroup
sudo cgset -r memory.limit_in_bytes=512M mygroup
# Запуск процесса в созданном cgroup
sudo cgexec -g memory:mygroup /usr/bin/myprocess
```
Пример использования namespaces:
```
# Запуск процесса в изолированном файловом пространстве
sudo unshare --mount-proc /bin/bash
# Запуск процесса с изолированным сетевым пространством
sudo unshare --net /bin/bash
```
Эти примеры демонстрируют, как с помощью cgroups и namespaces можно `создавать изолированные окружения для процессов в Linux`. В контексте контейнеризации, такие инструменты, как LXC, Docker и Kubernetes, используют cgroups и namespaces для создания и управления контейнерами, обеспечивая изоляцию ресурсов и системных аспектов для запущенных приложений.


## 11. Какие namespaces бывают? (Linux)

В Linux существует несколько типов namespaces:

1. `PID namespace`: Изолирует идентификаторы процессов, позволяя каждому контейнеру иметь свое собственное представление процессов в системе.

2. `Network namespace`: Изолирует сетевые ресурсы, такие как интерфейсы, IP-адреса, таблицы маршрутизации и т.д., позволяя каждому контейнеру иметь свое собственное сетевое пространство.

3. `Mount namespace`: Изолирует файловые системы и точки монтирования, позволяя каждому контейнеру иметь свою собственную файловую систему.

4. `UTS namespace`: Изолирует идентификаторы узла (название узла и доменное имя), позволяя каждому контейнеру иметь свое собственное название узла.

5. `IPC namespace`: Изолирует межпроцессное взаимодействие, такое как семафоры, очереди сообщений и разделяемая память.

6. `User namespace`: Изолирует идентификаторы пользователей и групп, позволяя каждому контейнеру иметь свои собственные пользователей и группы.

7. `Cgroups (control groups)` - это технология для управления и ограничения ресурсов, таких как CPU, память, сеть и другие, для группы процессов. Она не является частью namespaces, но часто используется вместе с ними для создания и управления контейнерами.

## 12. Нужно зайти на сервер и посмотреть потребление ресурсов. Процессор/Память/Диск/Сеть. Какими командами? (Linux)

Просмотр потребления ресурсов (процессор, память, диск, сеть) на сервере Linux:

1. `top`, `htop` - Онлайн просмотр MEMORY и CPU, NI (приоритет)

2. `free -h` - Просмотр использования памяти. 
    1. `lscpu` - информация о процессах
    2. `ps aux` - инфо о процессах (PID/USER/MEM/TIME/CPU)

3. `df -h`, `df -T`, `df -i` - Просмотр использования диска
    1. `du -axh --max-depth=1 /var` - folder used memory
    2. `tune2fs -l /dev/mapper/vg01-lv_var` - инфо по диску
    3. `ls -ltr | tail -1` - самый свежий файл
        1. `ls -lt | tail -1` - самый старый файл

4. `iftop`, `ip -s link` - Просмотр использования сети

5. `vgs` - volume groups

6. `iptables` - утилита для настройки правил брандмауэра в Linux. С помощью `iptables` можно управлять трафиком сетевых пакетов, определять, какие пакеты разрешены или блокированы, настраивать NAT (Network Address Translation), а также многое другое.

    Ключевые моменты об `iptables` (https://habr.com/ru/articles/747616/):

    1. **Таблицы**: `iptables` имеет различные таблицы, такие как `filter`, `nat`, `mangle`, `raw`, `security`. Каждая таблица используется для определенных целей, например, фильтрации пакетов (`filter`), NAT (`nat`), изменения заголовков пакетов (`mangle`).

    2. **Цепочки**: В рамках каждой таблицы существуют различные цепочки, такие как `INPUT`, `OUTPUT`, `FORWARD`. Цепочки определяют, куда направляются пакеты и какие правила применяются к ним.

    3. **Правила**: Правила `iptables` определяют, что делать с пакетами, которые проходят через брандмауэр. Правила могут разрешать, блокировать, перенаправлять или изменять пакеты в соответствии с заданными условиями.

    Через `iptables` можно просматривать текущие правила брандмауэра, смотреть статистику использования правил, добавлять новые правила, удалять и изменять существующие правила и т.д. 

    Например:

    1. `iptables -t nat -L` используется для просмотра правил NAT в таблице `nat`.
    2. `iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080` - для редиректа трафика с `--dport 80` до `--to-port 8080`
    3. `iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m limit --limit 3/min -j ACCEPT` - для ограничения скорости
    4. `iptables -A INPUT -j LOG --log-prefix "Dropped Packet: " iptables -A INPUT -j DROP` - логирование всех отброшенных пакетов

## 13. Чем отличается системное от пользовательского времени (процессорное)? (Linux)

1. Пользовательское время — это время, затраченное процессором на выполнение команд, заданных пользовательской программой. 
2. Системное время — это время, затраченное на выполнение операционной системой и различными системными службами. 
3. Процессорное время может быть разделено между несколькими задачами или программами.

## 14. В Allure-server - ошибка: "No space left on device" и путь. df -h показывает что место есть. В чем проблема? (Linux)

1. Закончились Inodes (мета данные).
2. Проверю кол-во свободных инод на диске `df -i` или `df -ih`
3. Нужно увеличить размер диска что повлечет увеличение свободных inodes.
    1. Либо изменить файловую систему на более подходящую под задачи сервиса/сервера.
    2. `df -T` - fs Type: `ext4` (улучшенная версия ext3), `btrfs`, `XFS`, `FAT32`, `NTFS`:
        1. `ext4` - max размер раздела: 50-100тб, max размер файла: 16тб, max кол-во файлов - 4млрд
        2. `XFS` - max размер раздела: 8 экзабайт, max размер файла: 8 экзабайт, max кол-во файлов - 2 в 64 степени

## 15. Как потюнить Файловую систему? Какой командой её можно улучшить? (Linux)

Настройка и оптимизация файловой системы в Linux может повысить производительность и эффективность работы сервера. Одной из команд, которая может помочь улучшить файловую систему, является `tune2fs`.

`Tune2fs` - это утилита для настройки параметров файловых систем ext2/ext3/ext4. Некоторые параметры, которые можно настроить с помощью `tune2fs`:

1. **Интервал проверки файловой системы**: Можно изменить интервал проверки файловой системы на наличие ошибок при помощи опции `-c` (по количеству монтирований) или `-i` (по времени).

2. **Интервал записи журнала**: Можно изменить интервал записи журнала файловой системы с помощью опции `-J`.

3. **Размер журнала**: Можно изменить размер журнала файловой системы с помощью опции `-j`.

4. **Метка файловой системы**: Можно установить метку файловой системы с помощью опции `-L`.

5. **Максимальное количество монтирований**: Можно установить максимальное количество монтирований перед проверкой файловой системы с помощью опции `-C`.

Примеры использования `tune2fs`:

- Установить интервал проверки файловой системы на 30 дней:
```bash
sudo tune2fs -i 30d /dev/sdX
```

- Установить метку файловой системы:
```bash
sudo tune2fs -L "mylabel" /dev/sdX
```

## 16. Как поднять приоритет выполнения процесса на процессоре? (Linux)

Управлять приоритетом выполнения процессов с помощью утилиты `nice` или команды `renice`. 
Приоритет процесса определяет, как часто процесс получает доступ к процессорным ресурсам. Чем ниже значение приоритета, тем выше приоритет у процесса.

1. **Установка приоритета с помощью `nice`**:
   - Команда `nice` используется для запуска процесса с измененным приоритетом. Чем больше значение приоритета, тем ниже приоритет у процесса.
   - Пример установки приоритета процесса на 10: `nice -n 10 command`
   - В данном примере `command` - это команда, для которой вы хотите изменить приоритет.

2. **Изменение приоритета с помощью `renice`**:
   - Команда `renice` позволяет изменить приоритет уже запущенного процесса.
   - Пример изменения приоритета процесса с PID 123 на 5: `renice 5 -p 123`
   - В данном примере `123` - это идентификатор процесса.

3. **Просмотр текущего приоритета процессов**:
   - Для просмотра текущего приоритета процессов можно использовать команду `top` или `htop`. Приоритет отображается в столбце `NI` (nice value).

Важно помнить, что установка слишком высокого приоритета для процесса может привести к замедлению работы других процессов на системе. Рекомендуется быть осторожным при изменении приоритетов процессов и учитывать потребности других процессов на сервере.

## 17. Символические ссылки и жесткие ссылки. В чем разница? (Linux)

Символические ссылки (`symbolic links`) и жесткие ссылки (`hard links`) - это два способа создания ссылок на файлы в UNIX-подобных операционных системах, таких как Linux. Они имеют разные особенности и применения:

1. **Жесткие ссылки (hard links)**: `ln file1.txt hardlink.txt`
   - Жесткая ссылка - это второе (или более) имя файла, которое указывает на те же данные на диске, что и первое имя.
   - Жесткие ссылки работают только в пределах одной файловой системы.
   - Удаление исходного файла не влияет на жесткие ссылки, так как они указывают на те же данные на диске.
   - Жесткие ссылки не могут быть созданы для директорий.
   - Изменения в одном файле отразятся во всех его жестких ссылках, так как все они указывают на одни и те же данные.
   - Имеет одинаковый id c оригиналом

2. **Символические ссылки (symbolic links)**: `ln -s file1.txt softlink.txt`
   - Символическая ссылка - это специальный файл, который содержит путь к другому файлу или директории.
   - Символические ссылки могут пересекать границы файловых систем и могут указывать на файлы, которые еще не существуют.
   - Если исходный файл удален, символическая ссылка становится битой и не может быть использована.
   - Символические ссылки могут быть созданы для директорий.
   - Изменения в исходном файле не влияют на символическую ссылку, так как она просто содержит путь к файлу.
   - Имеет разные id c оригиналом и является ссылкой (другой тип файла и другой id)

В общем, жесткие ссылки обеспечивают более непосредственное соединение между файлами, в то время как символические ссылки предоставляют более гибкую возможность ссылаться на файлы. Каждый тип ссылок имеет свои особенности и применения, и выбор между ними зависит от конкретной задачи.

`ls -l` - для просмотра информации о ссылках на файлы в столбце links

## 18. Как ограничить процесс по потребляемой оперативной памяти? (Linux)

1. Ограничение потребления оперативной памяти контейнера `gitlab-runner-bank2` в 250MB:

    **Шаг 1:** Найти ID контейнера `gitlab-runner-bank2` - `docker ps`

    **Шаг 2:** Команда `docker stats gitlab-runner-bank2` чтобы увидеть текущее потребление оперативной памяти

    **Шаг 3:** Установить ограничение на потребление оперативной памяти контейнера `docker update --memory 250m gitlab-runner-bank2`


2. Создание процесса в Linux и установки ограничения на его потребление оперативной памяти в 250MB:

    **Шаг 1:** Файл `light_process.sh` для создания процесса:
    ```bash
    #!/bin/bash

    while true
    do
        echo "Light process is running..."
        sleep 1000
    done
    ```

    **Шаг 2**: Сделайте скрипт исполняемым: `chmod +x light_process.sh`

    **Шаг 3**: Запустите скрипт light_process.sh в фоновом режиме: `./light_process.sh &`

    **Шаг 4**: Найдите PID (идентификатор процесса) запущенного процесса, используя команду ps: `ps aux | grep light_process.sh`

    **Шаг 5**: Установите ограничение на потребление оперативной памяти для процесса, используя утилиту cgroups. Создайте cgroup с именем `memory_limit` и установите ограничение в 250MB:
    ```bash
    sudo mkdir /sys/fs/cgroup/memory/memory_limit
    echo 250M > /sys/fs/cgroup/memory/memory_limit/memory.limit_in_bytes
    echo $$ > /sys/fs/cgroup/memory/memory_limit/tasks
    ```

    **Шаг 6**: Посмотреть текущий лимит и после его обновления:
    ```bash
    cat /sys/fs/cgroup/memory/memory_limit/memory.limit_in_bytes 
    9223372036854771712

    echo 250M > /sys/fs/cgroup/memory/memory_limit/memory.limit_in_bytes

    cat /sys/fs/cgroup/memory/memory_limit/memory.limit_in_bytes 
    262144000
    ```
    **Шаг 7**: Добавить PID процесса в созданную группу:
    ```bash
    echo 3327922 > /sys/fs/cgroup/memory/process1/tasks
    cat /sys/fs/cgroup/memory/memory_limit/tasks
    3327922
    3328466
    3329874
    ```

## 19. У нас есть директория, у неё права 755. Что это обозначает? (Linux)

Права 755:
1. (4+2+1=7) - владелец файла имеет права на чтение, запись и выполнение
2. (4+0+1=5) - группа и остальные пользователи имеют права только на чтение и выполнение

## 20. Что означает "Выполнение" для директории? (Linux)

1. Право на чтение позволяет пользователю получить список содержимого папки. 
2. Право на запись позволяет создавать и удалять файлы в этой папке. 
3. Право на исполнение разрешает перейти в эту папку:
    1. `cd /Users/andreyshabunov/PhpstormProjects/devops-interviews` - перейти в директорию
    2. `ls -l /Users/andreyshabunov/PhpstormProjects/devops-interviews` - список файлов директории

## 21. У нас есть директория, у неё права 700. Нужно не меняя владельца и права добавить доступ кому-то для работы с этой директорией. Как это сделать? (Linux)

Утилита `setfacl` позволяет управлять расширенными списками контроля доступа (ACL) в Linux:

1. Установить ACL для директории, чтобы включить расширенные списки контроля доступа:
   ```
   setfacl -m u:pberyozkin_adm:rwx /home/ashabunov_adm/test
   ```
   Добавить доступ для pberyozkin_adm

2. Посмотреть текущие ACL для директории:
   ```
   getfacl /home/ashabunov_adm/test/
   ```

3. Вывод команды `getfacl /home/ashabunov_adm/test/`:
    ```
    getfacl: Removing leading '/' from absolute path names
    # file: home/ashabunov_adm/test/
    # owner: ashabunov_adm
    # group: docker
    user::rwx
    user:pberyozkin_adm:rwx         #effective:---
    group::r-x                      #effective:---
    mask::---
    other::---
    ```

## 22. AppArmor и SELinux профиль. Приходилось ли дебажить и настраивать? (Linux)

`AppArmor` и `SELinux` - это две различные системы обязательного контроля доступа в Linux, которые обеспечивают дополнительный уровень безопасности для системы.

1. `AppArmor` (Application Armor) - это система контроля доступа, которая ограничивает возможности программ, устанавливая правила для их исполнения. AppArmor работает на уровне приложений и позволяет определить, какие ресурсы и операции приложение может использовать. Для настройки профилей безопасности в AppArmor используется специальный язык профилей.

2. `SELinux` (Security-Enhanced Linux) - это модуль ядра Linux, который предоставляет механизм обязательного контроля доступа на основе меток безопасности. SELinux управляет доступом к файлам, процессам, портам и другим ресурсам, определяя политики безопасности для различных объектов в системе.

Настройка профилей дебага и настройка в контексте AppArmor и SELinux может включать в себя определение правил доступа для конкретных приложений или сервисов, управление метками безопасности, а также настройку аудита и журналирования для отслеживания событий безопасности.

Обе системы обеспечивают возможность создания профилей безопасности для различных приложений и сервисов, что позволяет усилить защиту системы от различных угроз.

## 23. Cgroups изолируют ресурсы для контейнеров. Какая еще технология используется для контейнеризации? Ресурсы мы изолировали, но какая технология отвечает за процессы, которые мы видим в контейнерах? (Linux)

Для контейнеризации на Linux помимо **cgroups** (Control Groups), которые изолируют и управляют ресурсами, также используется технология **Namespaces**.

**Namespaces** - это механизм Linux, который обеспечивает изоляцию различных системных ресурсов для процессов. Когда процесс запускается в контейнере, он видит только свой собственный "виртуальный" вид операционной системы, созданный с помощью Namespaces. Это включает в себя изоляцию процессов, сетевых интерфейсов, файловых систем, IPC (межпроцессное взаимодействие) и других ресурсов.

Таким образом, **Namespaces** отвечают за изоляцию и виртуализацию системных ресурсов, делая контейнеры независимыми и безопасными для выполнения различных процессов внутри них.

- **Docker** является платформой для разработки, развертывания и управления контейнеризированными приложениями. Docker предоставляет удобный интерфейс и инструменты для создания, управления и запуска контейнеров на основе технологий, таких как Control Groups и Namespaces.

- **Runtime** в контексте контейнеризации обычно относится к программному обеспечению, которое отвечает за запуск и управление контейнерами. Одним из популярных рантаймов является **containerd**, который управляет жизненным циклом контейнеров, включая их создание, запуск, остановку и удаление.

- **Технологии в ядре (Kernel technologies)** относятся к различным механизмам и функциям, предоставляемым ядром операционной системы. В контексте контейнеризации на Linux, технологии в ядре, такие как Control Groups и Namespaces, обеспечивают изоляцию и управление ресурсами для контейнеров.

- **Docker** использует комбинацию **Control Groups** и **Namespaces** для обеспечения изоляции контейнеров. Control Groups позволяют управлять ресурсами, такими как CPU, память и дисковое пространство, в то время как Namespaces обеспечивают изоляцию процессов, сети и других системных ресурсов. Docker использует эти технологии в ядре Linux для создания и управления контейнерами, обеспечивая их изолированность и безопасность.
