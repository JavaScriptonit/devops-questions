## Вопросы:
1. Что такое CGroups?
2. Расскажи про сигналы в Linux. 
3. Какие бывают виды сигналов в Linux? 
4. Назвать все команды из 2ух букв.
5. Что такое код выхода и какие знаешь?
6. Виртуалка. df -h /home/user1 показывает примонтированный диск на 10Гб из которых 5Гб занято. При создании файла - Ошибка: "No space left on device". Что это может быть?
7. Что такое procfs?
8. Описание файлов и директории из ProcFS.
9. Что такое "strace"?
10. Какая технология лежит в основе всей контейнеризации в Linux? (Linux)
11. Какие namespaces бывают? (Linux)
12. 

## 1. Что такое CGroups? (Linux)
sber/devices/interview.md - 11. Какие namespaces бывают? (Linux)

`Cgroups (control groups)` - это технология для управления и ограничения ресурсов, таких как CPU, память, сеть и другие, для группы процессов. Она не является частью namespaces, но часто используется вместе с ними для создания и управления контейнерами.

## 2. Расскажи про сигналы в Linux. (Linux)

В Linux сигналы - это механизм, который используется для управления процессами. Сигналы могут быть отправлены процессу для уведомления о различных событиях или для управления его поведением.

Два из наиболее часто используемых сигналов в Linux:

1. SIGKILL (сигнал 9): Этот сигнал используется для немедленного завершения процесса. Процесс не имеет возможности обработать или игнорировать SIGKILL. Этот сигнал обычно используется для принудительного завершения процесса в случае критической ошибки.

Пример команды для отправки SIGKILL процессу с определенным PID (например, PID=1234):
```bash
kill -9 1234
```

2. SIGTERM (сигнал 15): Этот сигнал также используется для завершения процесса, но он более "мягкий" по сравнению с SIGKILL. Процесс имеет возможность обработать SIGTERM и выполнить необходимые действия перед завершением. Этот сигнал часто используется для грациозного завершения процесса.

Пример команды для отправки SIGTERM процессу с определенным PID (например, PID=1234):
```bash
kill -15 1234
```

Сигналы в Linux используются для различных целей, таких как управление процессами, обработка ошибок, перезагрузка сервисов и другие операции. Правильное использование сигналов помогает в управлении процессами и решении различных задач в операционной системе.

## 3. Какие бывают виды сигналов в Linux? (Linux)

В Linux существует много различных сигналов, каждый из которых имеет свою уникальную функцию. Некоторые из наиболее важных и часто используемых сигналов включают в себя:

1. **SIGINT (сигнал 2)**: Используется для прерывания (interrupt) процесса, обычно посылается при нажатии комбинации клавиш Ctrl+C.

2. **SIGTERM (сигнал 15)**: Уведомляет процесс о необходимости завершения. Часто используется для грациозного завершения процесса.

3. **SIGKILL (сигнал 9)**: Принудительно завершает процесс без возможности обработки сигнала. Обычно используется в критических ситуациях.

4. **SIGHUP (сигнал 1)**: Посылается процессу при отключении терминала или при перезапуске демона.

5. **SIGUSR1 (сигнал 10)** и **SIGUSR2 (сигнал 12)**: Пользовательские сигналы, которые могут использоваться для специфических задач в приложениях.

Всего в Linux существует более 30 различных сигналов. Каждый сигнал имеет свой уникальный номер и назначение. Некоторые сигналы могут быть перехвачены и обработаны программами, в то время как другие приводят к немедленному завершению процесса. Корректное использование сигналов важно для управления процессами и обеспечения стабильной работы системы.

## 4. Назвать все команды из 2ух букв.
```
ls, ps, cd, mw, rm, ln, lp, df, du, fg, ip, su, vi, cp, mc
```

## 5. Что такое код выхода и какие знаешь?
```
1	разнообразные ошибки
2	согласно документации к Bash -- неверное использование встроенных команд
126	вызываемая команда не может быть выполнена
127	"команда не найдена"
128	неверный аргумент команды exit
128+n	фатальная ошибка по сигналу "n"
130	завершение по Control-C
255*	код завершения вне допустимого диапазона
```

## 6. Виртуалка. df -h /home/user1 показывает примонтированный диск на 10Гб из которых 5Гб занято. При создании файла - Ошибка: "No space left on device". Что это может быть?
    1. Ребут: `sudo reboot`
    2. Проверка mount /etc/fstab: `sudo mount -a`
    3. Проверить symbolic link and hard link: `ls -l`
        1. `find . -type l` - найти линки
        2. `readlink имя_символической_ссылки` -  узнать, на что указывает символическая ссылка
    4. Проверить кол-во свободных inodes: `df -T`
    Ответ: Проблема была из-за отсутствия свободных inodes на диске. 2 решения: добавить памяти на диск для увеличения кол-ва инод или изменить файловую систему.

## 7. Что такое procfs?
    1. `ProcFS` — специальная файловая система, используемая в Linux, позволяет получить доступ к информации из ядра о системных процессах.
    2. `ps -ef` - выведет список всех запущенных на данный момент процессов:
    ```
    UID        PID  PPID  C STIME TTY          TIME CMD
    root         1     0  0 11:08 ?        00:00:04 init
    root         2     1  0 11:08 ?        00:00:00 [keventd]
    mbutcher  1219  1207  0 12:23 pty/s2   00:00:00 /bin/bash
    root         8     1  0 11:08 ?        00:00:00 [kjournald]
    ```

## 8. Описание файлов и директории из ProcFS.
```
/proc/PID/cmdline – аргументы командной строки (где PID – идентификатор процесса или self);
/proc/PID/environ – переменные окружения для данного процесса;
/proc/PID/status – статус процесса;
/proc/PID/fd – директория, содержащая символьные ссылки на каждый открытый файловый дескриптор;
/proc/cpuinfo – информация о процессоре (производитель, модель, поколение и т.п.);
/proc/cmdline – параметры, передаваемые ядру при загрузке;
/proc/uptime – количество секунд, прошедших с момента загрузки ядра и проведенных в режиме бездействия;
/proc/version – содержит информацию о версии ядра, компилятора и другую информацию, связанную с загруженным ядром.
/proc/sys/fs/file-max - показывает предел Max Open File Limit (обозначающий число одновременно открытых файлов)
/proc/sys/fs/file-nr - по порядку параметр выдает три значения: число открытых в данный момент файлов; число открытых, но не используемых файлов; максимальное число открытых файлов
```

## 9. Что такое "strace"?
    1. Утилита strace предназначена для отслеживания системных вызовов, которые выполняются процессом в операционной системе Linux. Она позволяет наблюдать взаимодействие между процессом и операционной системой, отслеживая системные вызовы, сигналы, чтение и запись файлов, а также другие операции ввода-вывода.
        1. `strace -p <PID>` - где <PID> - идентификатор процесса, который вы хотите отследить.

## 10. Какая технология лежит в основе всей контейнеризации в Linux? (Linux)

В основе контейнеризации в Linux лежит технология `Linux-контейнеров (LXC)`, которая представляет собой механизм изоляции процессов и ресурсов внутри операционной системы Linux. LXC позволяет создавать и управлять контейнерами, которые являются легковесными виртуальными средами, изолированными друг от друга и от хост-системы.

Однако, следует отметить, что LXC представляет более `низкоуровневый подход к контейнеризации`, и его использование напрямую может потребовать дополнительных инструментов и управления. В более современных подходах к контейнеризации, таких как Docker, используется более высокоуровневый интерфейс для управления контейнерами, который упрощает их создание, управление и развертывание.

Таким образом, хотя LXC является основой контейнеризации в Linux, для более удобного и гибкого использования контейнеров часто применяются более высокоуровневые инструменты, такие как Docker, Kubernetes и т.д.

-----------------------

В основе контейнеризации в Linux лежат две основные технологии: `cgroups (control groups)` и `namespaces`.

`Cgroups` позволяют ограничивать и изолировать потребление ресурсов, таких как CPU, память, сетевые ресурсы и другие, для процессов внутри контейнера. Это обеспечивает контроль над ресурсами, используемыми контейнером, и предотвращает переполнение или конфликты ресурсов между контейнерами и хост-системой.

`Namespaces` обеспечивают изоляцию различных аспектов операционной системы для процессов внутри контейнера. Например, с помощью namespaces можно изолировать файловую систему, сетевое пространство и другие системные ресурсы, чтобы контейнер видел только свою собственную "виртуальную" версию этих ресурсов.

Используя cgroups и namespaces, Linux обеспечивает основу для контейнеризации, а инструменты, такие как Docker, используют эти технологии для удобного управления контейнерами. Благодаря этим технологиям контейнеризация стала широко распространенным и эффективным методом изоляции и управления приложениями в современных системах.

-----------------------

Пример использования cgroups:
```
# Создание cgroup для ограничения использования памяти
sudo cgcreate -g memory:mygroup
# Ограничение использования памяти контейнером в cgroup
sudo cgset -r memory.limit_in_bytes=512M mygroup
# Запуск процесса в созданном cgroup
sudo cgexec -g memory:mygroup /usr/bin/myprocess
```
Пример использования namespaces:
```
# Запуск процесса в изолированном файловом пространстве
sudo unshare --mount-proc /bin/bash
# Запуск процесса с изолированным сетевым пространством
sudo unshare --net /bin/bash
```
Эти примеры демонстрируют, как с помощью cgroups и namespaces можно `создавать изолированные окружения для процессов в Linux`. В контексте контейнеризации, такие инструменты, как LXC, Docker и Kubernetes, используют cgroups и namespaces для создания и управления контейнерами, обеспечивая изоляцию ресурсов и системных аспектов для запущенных приложений.


## 11. Какие namespaces бывают? (Linux)

В Linux существует несколько типов namespaces:

1. `PID namespace`: Изолирует идентификаторы процессов, позволяя каждому контейнеру иметь свое собственное представление процессов в системе.

2. `Network namespace`: Изолирует сетевые ресурсы, такие как интерфейсы, IP-адреса, таблицы маршрутизации и т.д., позволяя каждому контейнеру иметь свое собственное сетевое пространство.

3. `Mount namespace`: Изолирует файловые системы и точки монтирования, позволяя каждому контейнеру иметь свою собственную файловую систему.

4. `UTS namespace`: Изолирует идентификаторы узла (название узла и доменное имя), позволяя каждому контейнеру иметь свое собственное название узла.

5. `IPC namespace`: Изолирует межпроцессное взаимодействие, такое как семафоры, очереди сообщений и разделяемая память.

6. `User namespace`: Изолирует идентификаторы пользователей и групп, позволяя каждому контейнеру иметь свои собственные пользователей и группы.

7. `Cgroups (control groups)` - это технология для управления и ограничения ресурсов, таких как CPU, память, сеть и другие, для группы процессов. Она не является частью namespaces, но часто используется вместе с ними для создания и управления контейнерами.
