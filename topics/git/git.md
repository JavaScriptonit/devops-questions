## Вопросы:
1. Отличие Git stash от Git rebase? (Git)
2. Что такое Git Cherry pick? (Git)
3. Отличие Git merge от Git rebase? (Git)
4. Что показывает команда "git log -100" при "git merge" и "git rebase"? (Git)
5. Какие методы решения merge-conflicts ты знаешь? (Git)
6. Как создать merge-conflict? Какие шаги? (Git)
7. Репозиторий с helm-charts. Открыли ветку. Добавили правку. Делаем MR и получаем конфликт. Как решить конфликт? (Git)
8. Что такое GitOps? (Git)
9. Что такое GitFlow? Как принято работать над задачей в ветке? (Git)
10. Что такое DevSecOps? Какие таски они добавляют в пайплайны? Какие задачи ставятся инженеру? (Git)
11. Примеры утилит в рамках DevSecOps пайплайнов. (Git)


## 1. Отличие Git stash от Git rebase? (Git)

### Git stash:

https://www.atlassian.com/ru/git/tutorials/saving-changes/git-stash

Команда `git stash` позволяет на время «сдать в архив» (или отложить) изменения, сделанные в рабочей копии, чтобы вы могли применить их позже. Откладывание изменений полезно, если вам необходимо переключить контекст и вы пока не готовы к созданию коммита.

Теперь вы можете вносить изменения, создавать новые коммиты, переключаться между ветками и выполнять другие операции Git. По необходимости отложенные изменения можно будет применить позже.

Отложенные изменения сохраняются в локальном репозитории Git и не передаются на сервер при выполнении команды push.

```
$ git status
Changes to be committed:
    new file:   style.css

$ git stash
Saved working directory and index state WIP on main: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage

$ git status
On branch main
nothing to commit, working tree clean
```

Применение отложенных изменений:
```
git stash pop
```

Управление несколькими наборами отложенных изменений:
```
$ git stash list
stash@{0}: WIP on main: 5002d47 our new homepage
stash@{1}: WIP on main: 5002d47 our new homepage
stash@{2}: WIP on main: 5002d47 our new homepage
```

`git stash show` - Просмотр различий между наборами отложенных изменений

`git stash branch` - Создание ветки из отложенных изменений

`git stash drop stash@{1}` - Удаление отложенных изменений

### Git rebase:

https://www.atlassian.com/ru/git/tutorials/rewriting-history/git-rebase

Перебазирование — это процесс перемещения последовательности коммитов к новому базовому коммиту или их объединение. Операцию перебазирования удобнее всего применить и отобразить в контексте создания функциональных веток. В общих чертах процесс можно представить следующим образом:

С точки зрения содержимого перебазирование — это замена одного коммита в основании ветки на другой, в результате чего создается впечатление, что ветка получила новое начало. В процессе этой операции Git создает новые коммиты и применяет их к указанному основанию, поэтому важно понимать, что в действительности ветка всегда состоит из совершенно новых коммитов.

`Интерактивное перебазирование позволяет полностью контролировать состояние истории проекта.` Это дает разработчикам большую свободу, поскольку они могут зафиксировать засоренную историю, не отрываясь от написания кода, и очистить ее позже.

Большинство разработчиков используют интерактивное перебазирование, чтобы придать функциональной ветке аккуратность перед слиянием с основной базой кода. Они могут склеить незначительные коммиты, удалить устаревшие элементы и в целом навести порядок в ветке, прежде чем выполнить перенос в «официальную» историю проекта. Со стороны будет казаться, что для разработки функции потребовалось лишь несколько коммитов и тщательное планирование.

Оценить эффективность интерактивного перебазирования можно, взглянув на получившуюся историю ветки main. В глазах окружающих вы будете блестящим разработчиком, который внедрил новую функцию с первого раза и без лишних коммитов. `Так интерактивное перебазирование помогает поддерживать порядок в истории проекта, а также сохраняет целесообразность каждого ее элемента.`

## 2. Что такое Git Cherry pick? (Git)

https://www.atlassian.com/ru/git/tutorials/cherry-pick#

`git cherry-pick` — это полезная команда, с помощью которой можно выборочно применить коммиты Git к текущей рабочей ветке HEAD. С ее помощью можно выбрать коммит из одной ветки и применить его к другой. Команда `git cherry-pick` — это удобный способ отменить изменения. Например, если коммит попал в ветку по ошибке, вы можете переключиться на нужную ветку и выполнить перенос.

Пользоваться командой `git cherry-pick` удобно, однако это не всегда оптимально. Она может привести к дублированию коммитов, поэтому нередко разработчики предпочитают обычное слияние. Таким образом, можно сказать, что команда `git cherry-pick` — средство эффективное, но узконаправленное.

Пример использования:
Если был обнаружен баг, важно как можно скорее предоставить исправление конечным пользователям. Рассмотрим пример, когда разработчик начинает создавать новую функцию. `В ходе работы обнаруживается существующий баг`, и разработчик создает специальный коммит для его исправления. Этот `коммит можно перенести прямо в основную ветку (main)`, чтобы исправить баг, прежде чем от него пострадают другие пользователи.

## 3. Отличие Git merge от Git rebase? (Git)

`Git merge` и `Git rebase` - это два различных способа объединения изменений из одной ветки в другую. Пример визуализации обоих методов:

У нас есть две ветки: "master" и "feature-branch". Обе ветки содержат одинаковые изменения.
```
   A---B---C  master
        \
         D---E  feature-branch
```
Теперь рассмотрим, что происходит при использовании Git merge и Git rebase:

`Git merge`: При использовании Git merge, изменения из "feature-branch" объединяются с "master" с сохранением истории каждой ветки. Это создает новый коммит, который объединяет изменения обеих веток.
```
   A---B---C------F  master
        \        /
         D---E---  feature-branch
```
`Git rebase`: При использовании Git rebase, изменения из "feature-branch" переносятся поверх "master", создавая новую историю коммитов без дополнительных коммитов слияния.
```
   A---B---C  master
            \
             D'---E'  feature-branch
```
### В каких случаях нужно использовать Git merge и Git rebase:

1. Используйте Git merge, если вы хотите сохранить оригинальную историю коммитов каждой ветки и хотите, чтобы объединенная ветка содержала дополнительный коммит слияния.

2. Используйте Git rebase, если вы хотите, чтобы история коммитов была линейной и чистой, без дополнительных коммитов слияния. Это может быть полезно, когда вы работаете над функциональным изменением и хотите, чтобы история коммитов выглядела более логично.

3. Важно помнить, что при использовании Git rebase следует быть осторожным, особенно если ваш репозиторий используется другими разработчиками, так как это изменяет историю коммитов и может привести к конфликтам, если другие разработчики уже скачали изменения из вашей ветки.

4. Дополнительное важное отличие между `git merge` и `git rebase` заключается в том, что `git merge` имеет различные стратегии слияния, в то время как `git rebase` не имеет никаких стратегий. 
  1. При использовании `git merge`, вы можете выбрать различные стратегии слияния, такие как `--no-ff` (не быстро-передвигаемое слияние) или `--squash` (сквош-слияние), которые позволяют вам контролировать, как именно происходит слияние и какие коммиты включаются в итоговый коммит слияния.
  2. https://blog.developer.atlassian.com/pull-request-merge-strategies-the-great-debate/ - Merge Strategies

## 4. Что показывает команда "git log -100" при "git merge" и "git rebase"? (Git)

Команда `git log -100` используется для просмотра последних 100 коммитов в истории репозитория. При использовании этой команды после выполнения операций `git merge` и `git rebase`, вы увидите различия в истории коммитов в зависимости от того, какая операция была выполнена.

`git merge`: При выполнении операции git merge, создается новый коммит, который объединяет изменения из ветки, которую вы сливаете, с вашей текущей веткой. После выполнения слияния и применения команды git log -100, вы увидите, что история коммитов будет включать коммиты из обеих веток, а также коммит слияния, который объединяет изменения.

`git rebase:` При выполнении операции git rebase, коммиты из вашей текущей ветки "перебазируются" на вершину целевой ветки. Это означает, что вместо создания нового коммита слияния, коммиты из вашей ветки будут перемещены поверх коммитов целевой ветки. После выполнения операции git log -100, вы увидите, что история коммитов будет линейной, без коммитов слияния, так как перебазирование создает новую историю коммитов без создания дополнительных коммитов слияния.

Таким образом, основное различие между git merge и git rebase в отображении истории коммитов после выполнения операций. git merge создает коммит слияния, который отображается в истории, в то время как git rebase изменяет историю коммитов, делая ее линейной и без коммитов слияния.


## 5. Какие методы решения merge-conflicts ты знаешь? (Git)

Существует несколько методов решения конфликтов слияния (merge conflicts) в Git:

1. `Ручное разрешение конфликтов`: Этот метод включает в себя ручное редактирование файлов с конфликтами слияния. Git помечает конфликтные участки в файлах специальными маркерами (<<<<<<<, =======, >>>>>>>), и вам нужно вручную выбрать, какую версию кода оставить и какую удалить.

2. `Git mergetool`: Git предоставляет возможность использовать внешние инструменты для разрешения конфликтов. Вы можете настроить Git для использования специальных программ для слияния файлов, таких как KDiff3, P4Merge, VimDiff и других, чтобы визуально разрешать конфликты.

3. `Отмена слияния`: Если вы столкнулись с трудно разрешимыми конфликтами или хотите начать слияние заново, вы можете отменить слияние с помощью команды git merge --abort.

4. `Использование режима --ours и --theirs`: С помощью опций git checkout --ours <file> и git checkout --theirs <file> вы можете выбрать, какую версию файла использовать в случае конфликта.

5. `Использование интерактивного режима rebase`: При использовании git rebase вы можете воспользоваться интерактивным режимом, чтобы выбирать, какие изменения применять и какие отклонять в процессе перебазирования.

## 6. Как создать merge-conflict? Какие шаги? (Git)

Чтобы создать конфликт слияния (merge conflict) между ветками `master` и `feature-branch1`, вы можете выполнить следующие шаги:

1. **Измените файл `file.md` в ветке `master`**:
   Внесите изменения в файл `file.md` в ветке `master`, например, добавьте строку "string4" в файл.

   ```plaintext
   string1
   string2
   string3
   string4
   ```

2. **Измените тот же файл `file.md` в ветке `feature-branch1`**:
   Теперь внесите изменения в файл `file.md` в ветке `feature-branch1`, например, добавьте строку "string5" в файл.

   ```plaintext
   string1
   string2
   string3
   string5
   ```

3. **Попытайтесь слить ветку `feature-branch1` в ветку `master`**:
   После внесения изменений в обе ветки, попытайтесь выполнить операцию слияния (merge) ветки `feature-branch1` в ветку `master` с помощью команды `git merge feature-branch1`. Git обнаружит конфликт из-за изменений, внесенных в одном и том же месте файла `file.md` в разных ветках.

После выполнения этих шагов вы должны увидеть сообщение о конфликте слияния в Git, и файл `file.md` будет содержать маркеры конфликта, указывающие на конфликтные участки кода.

## 7. Репозиторий с helm-charts. Открыли ветку. Добавили правку. Делаем MR и получаем конфликт. Как решить конфликт? (Git)

Для разрешения конфликта при слиянии веток, вам потребуется выполнить следующие шаги:

1. **Открыть конфликтный файл:**
   - Найдите файл, в котором возник конфликт при слиянии.
   - Откройте этот файл в текстовом редакторе.

2. **Понять структуру конфликта:**
   - Обычно конфликт отображается в файле с пометками `<<<<<<<`, `=======` и `>>>>>>>`. 
   - `<<<<<<<` обозначает начало изменений из вашей ветки.
   - `=======` разделяет ваш код и код из другой ветки.
   - `>>>>>>>` обозначает конец изменений из другой ветки.

3. **Решить конфликт:**
   - Проанализируйте изменения из обеих веток и решите, какие изменения следует сохранить.
   - Удалите метки `<<<<<<<`, `=======` и `>>>>>>>`, а также ненужные части кода.
   - Оставьте только те изменения, которые необходимо сохранить после слияния.

4. **Добавить изменения и завершить слияние:**
   - После разрешения конфликта сохраните изменения в файле.
   - Добавьте изменения в индекс с помощью команды `git add <file_name>`.
   - Завершите слияние с помощью команды `git merge --continue`.

## 8. Что такое GitOps? (Git)

**GitOps** - это методология управления инфраструктурой и процессом развертывания приложений, основанная на использовании систем контроля версий, таких как Git. Основная идея GitOps заключается в том, что вся инфраструктура и конфигурация приложений хранятся в репозитории Git, а изменения в этой конфигурации приводят к автоматическому обновлению инфраструктуры и приложений.

**Основные принципы GitOps:**
1. **Декларативное управление**: Инфраструктура и конфигурация приложений описываются в виде декларативных файлов (например, YAML), которые хранятся в Git репозитории.

2. **Автоматизация**: Изменения в Git репозитории автоматически приводят к обновлению инфраструктуры и приложений с использованием CI/CD пайплайнов.

3. **Синхронизация состояния**: Состояние инфраструктуры всегда должно соответствовать состоянию, описанному в Git репозитории. Если произошли изменения, система должна автоматически привести инфраструктуру к желаемому состоянию.

4. **Операционная безопасность**: Git история служит источником правды о том, какая конфигурация была задана и какие изменения были внесены, что обеспечивает операционную безопасность.

GitOps позволяет упростить управление инфраструктурой, обеспечить ее надежность и повысить скорость развертывания приложений. Этот подход особенно популярен в области облачных вычислений и контейнеризации, так как позволяет эффективно управлять инфраструктурой в современных динамичных средах разработки.

## 9. Что такое GitFlow? Как принято работать над задачей в ветке? (Git)

**GitFlow** - это модель ветвления и организации рабочего процесса при использовании системы контроля версий Git. Эта модель была предложена Vincent Driessen и стала популярной среди разработчиков благодаря своей структуре и четким правилам ветвления.

Основные принципы GitFlow включают в себя следующие типы веток:

1. **Master (основная ветка)**: В этой ветке содержится стабильная версия продукта. Новые изменения попадают в нее только после успешного завершения всех тестов.

2. **Develop (ветка разработки)**: В этой ветке ведется основная работа над новыми функциями и исправлением ошибок. От нее отводятся отдельные ветки для каждой задачи.

3. **Feature (ветка функции)**: Для каждой новой функции создается отдельная ветка от ветки `develop`. После завершения работы над функцией ветка сливается обратно в `develop`.

4. **Release (ветка релиза)**: Подготовка к выпуску новой версии происходит в этой ветке. В нее могут попадать исправления ошибок и подготовка документации.

5. **Hotfix (ветка исправлений)**: Используется для быстрого исправления критических ошибок в продакшене. Создается от `master` и после исправления сливается как в `master`, так и в `develop`.

Чтобы работать над задачей в ветке в соответствии с GitFlow, следуйте этим шагам:

1. Создайте ветку от ветки `develop` с названием, отражающим характер задачи:  
   ```bash
   git checkout develop
   git pull origin develop
   git checkout -b feature/new-feature
   ```

2. Работайте над задачей в созданной ветке, делая коммиты по мере продвижения работы.

3. После завершения задачи и тестирования, выполните слияние ветки с веткой `develop`:  
   ```bash
   git checkout develop
   git pull origin develop
   git merge --no-ff feature/new-feature
   git push origin develop
   ```

4. Удалите ветку, если она больше не нужна:  
   ```bash
   git branch -d feature/new-feature
   ```

Следование модели GitFlow помогает организовать рабочий процесс, упростить управление версиями и обеспечить стабильность разработки.

## 10. Что такое DevSecOps? Какие таски они добавляют в пайплайны? Какие задачи ставятся инженеру? (Git)

**DevSecOps** - это практика интеграции безопасности в процесс разработки и поставки программного обеспечения (DevOps). DevSecOps объединяет разработчиков, операционных специалистов и специалистов по информационной безопасности для обеспечения безопасности приложений с самого начала их жизненного цикла.

В пайплайны DevSecOps добавляются специфические таски, направленные на обеспечение безопасности приложений:

1. **Статический анализ кода (Static Code Analysis)**: Проверка и анализ исходного кода на предмет потенциальных уязвимостей и ошибок без его запуска.

2. **Динамический анализ безопасности (Dynamic Security Analysis)**: Запуск приложения для выявления уязвимостей и угроз в реальном времени.

3. **Анализ зависимостей (Dependency Analysis)**: Проверка наличия уязвимостей в сторонних библиотеках и зависимостях.

4. **Тестирование на проникновение (Penetration Testing)**: Специальные тесты, направленные на поиск уязвимостей с использованием методов хакеров.

5. **Мониторинг безопасности (Security Monitoring)**: Организация мониторинга безопасности приложения в реальном времени.

Инженеры, работающие в DevSecOps, сталкиваются с такими задачами:

1. **Интеграция безопасности в CI/CD пайплайны**: Настройка инструментов безопасности и автоматизация их использования в процессе разработки и поставки.

2. **Обучение и обучение персонала**: Обучение команды разработчиков и операционных специалистов в области безопасности и лучших практик DevSecOps.

3. **Разработка и внедрение политик безопасности**: Создание и внедрение стандартов безопасности для приложений и инфраструктуры.

4. **Реагирование на инциденты безопасности**: Быстрое реагирование на обнаруженные уязвимости и инциденты безопасности.

DevSecOps помогает снизить риски безопасности, повысить защиту приложений и обеспечить безопасность в целом в рамках DevOps процесса разработки и поставки программного обеспечения.

## 11. Примеры утилит в рамках DevSecOps пайплайнов. (Git)

Несколько популярных утилит для проверки безопасности кода в рамках DevSecOps пайплайнов и примеры команд, которые они используют для анализа безопасности:

1. **SAST (Static Application Security Testing)**:
   - **Инструмент**: **SonarQube**
   - **Команда**:  
     ```
     $ sonar-scanner -Dsonar.projectKey=my_project_key -Dsonar.sources=.
     ```
   
2. **DAST (Dynamic Application Security Testing)**:
   - **Инструмент**: **OWASP ZAP (Zed Attack Proxy)**
   - **Команда**:  
     ```
     $ zap-cli -cmd -quickurl http://example.com
     ```

3. **Dependency Analysis**:
   - **Инструмент**: **OWASP Dependency-Check**
   - **Команда**:  
     ```
     $ dependency-check.sh --scan /path/to/project
     ```

4. **Penetration Testing**:
   - **Инструмент**: **Nmap**
   - **Команда**:  
     ```
     $ nmap -sV -p 1-65535 example.com
     ```

5. **Security Monitoring**:
   - **Инструмент**: **Snyk**
   - **Команда**:  
     ```
     $ snyk test
     ```

Эти утилиты помогают обнаруживать уязвимости в коде, зависимостях и инфраструктуре, а также проводить тестирование на проникновение для повышения безопасности приложений. Использование таких инструментов в пайплайнах разработки помогает обеспечить непрерывную безопасность и защиту приложений.