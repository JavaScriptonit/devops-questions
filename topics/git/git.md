## Вопросы:
1. Отличие Git stash от Git rebase? (Git)
2. Что такое Git Cherry pick? (Git)
3. Отличие Git merge от Git rebase? (Git)
4. Что показывает команда "git log -100" при "git merge" и "git rebase"? (Git)
5. Какие методы решения merge-conflicts ты знаешь? (Git)
6. Как создать merge-conflict? Какие шаги? (Git)
7. Репозиторий с helm-charts. Открыли ветку. Добавили правку. Делаем MR и получаем конфликт. Как решить конфликт? (Git)
8. 
9. 

## 1. Отличие Git stash от Git rebase? (Git)

### Git stash:

https://www.atlassian.com/ru/git/tutorials/saving-changes/git-stash

Команда `git stash` позволяет на время «сдать в архив» (или отложить) изменения, сделанные в рабочей копии, чтобы вы могли применить их позже. Откладывание изменений полезно, если вам необходимо переключить контекст и вы пока не готовы к созданию коммита.

Теперь вы можете вносить изменения, создавать новые коммиты, переключаться между ветками и выполнять другие операции Git. По необходимости отложенные изменения можно будет применить позже.

Отложенные изменения сохраняются в локальном репозитории Git и не передаются на сервер при выполнении команды push.

```
$ git status
Changes to be committed:
    new file:   style.css

$ git stash
Saved working directory and index state WIP on main: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage

$ git status
On branch main
nothing to commit, working tree clean
```

Применение отложенных изменений:
```
git stash pop
```

Управление несколькими наборами отложенных изменений:
```
$ git stash list
stash@{0}: WIP on main: 5002d47 our new homepage
stash@{1}: WIP on main: 5002d47 our new homepage
stash@{2}: WIP on main: 5002d47 our new homepage
```

`git stash show` - Просмотр различий между наборами отложенных изменений

`git stash branch` - Создание ветки из отложенных изменений

`git stash drop stash@{1}` - Удаление отложенных изменений

### Git rebase:

https://www.atlassian.com/ru/git/tutorials/rewriting-history/git-rebase

Перебазирование — это процесс перемещения последовательности коммитов к новому базовому коммиту или их объединение. Операцию перебазирования удобнее всего применить и отобразить в контексте создания функциональных веток. В общих чертах процесс можно представить следующим образом:

С точки зрения содержимого перебазирование — это замена одного коммита в основании ветки на другой, в результате чего создается впечатление, что ветка получила новое начало. В процессе этой операции Git создает новые коммиты и применяет их к указанному основанию, поэтому важно понимать, что в действительности ветка всегда состоит из совершенно новых коммитов.

`Интерактивное перебазирование позволяет полностью контролировать состояние истории проекта.` Это дает разработчикам большую свободу, поскольку они могут зафиксировать засоренную историю, не отрываясь от написания кода, и очистить ее позже.

Большинство разработчиков используют интерактивное перебазирование, чтобы придать функциональной ветке аккуратность перед слиянием с основной базой кода. Они могут склеить незначительные коммиты, удалить устаревшие элементы и в целом навести порядок в ветке, прежде чем выполнить перенос в «официальную» историю проекта. Со стороны будет казаться, что для разработки функции потребовалось лишь несколько коммитов и тщательное планирование.

Оценить эффективность интерактивного перебазирования можно, взглянув на получившуюся историю ветки main. В глазах окружающих вы будете блестящим разработчиком, который внедрил новую функцию с первого раза и без лишних коммитов. `Так интерактивное перебазирование помогает поддерживать порядок в истории проекта, а также сохраняет целесообразность каждого ее элемента.`

## 2. Что такое Git Cherry pick? (Git)

https://www.atlassian.com/ru/git/tutorials/cherry-pick#

`git cherry-pick` — это полезная команда, с помощью которой можно выборочно применить коммиты Git к текущей рабочей ветке HEAD. С ее помощью можно выбрать коммит из одной ветки и применить его к другой. Команда `git cherry-pick` — это удобный способ отменить изменения. Например, если коммит попал в ветку по ошибке, вы можете переключиться на нужную ветку и выполнить перенос.

Пользоваться командой `git cherry-pick` удобно, однако это не всегда оптимально. Она может привести к дублированию коммитов, поэтому нередко разработчики предпочитают обычное слияние. Таким образом, можно сказать, что команда `git cherry-pick` — средство эффективное, но узконаправленное.

Пример использования:
Если был обнаружен баг, важно как можно скорее предоставить исправление конечным пользователям. Рассмотрим пример, когда разработчик начинает создавать новую функцию. `В ходе работы обнаруживается существующий баг`, и разработчик создает специальный коммит для его исправления. Этот `коммит можно перенести прямо в основную ветку (main)`, чтобы исправить баг, прежде чем от него пострадают другие пользователи.

## 3. Отличие Git merge от Git rebase? (Git)

`Git merge` и `Git rebase` - это два различных способа объединения изменений из одной ветки в другую. Пример визуализации обоих методов:

У нас есть две ветки: "master" и "feature-branch". Обе ветки содержат одинаковые изменения.
```
   A---B---C  master
        \
         D---E  feature-branch
```
Теперь рассмотрим, что происходит при использовании Git merge и Git rebase:

`Git merge`: При использовании Git merge, изменения из "feature-branch" объединяются с "master" с сохранением истории каждой ветки. Это создает новый коммит, который объединяет изменения обеих веток.
```
   A---B---C------F  master
        \        /
         D---E---  feature-branch
```
`Git rebase`: При использовании Git rebase, изменения из "feature-branch" переносятся поверх "master", создавая новую историю коммитов без дополнительных коммитов слияния.
```
   A---B---C  master
            \
             D'---E'  feature-branch
```
### В каких случаях нужно использовать Git merge и Git rebase:

1. Используйте Git merge, если вы хотите сохранить оригинальную историю коммитов каждой ветки и хотите, чтобы объединенная ветка содержала дополнительный коммит слияния.

2. Используйте Git rebase, если вы хотите, чтобы история коммитов была линейной и чистой, без дополнительных коммитов слияния. Это может быть полезно, когда вы работаете над функциональным изменением и хотите, чтобы история коммитов выглядела более логично.

3. Важно помнить, что при использовании Git rebase следует быть осторожным, особенно если ваш репозиторий используется другими разработчиками, так как это изменяет историю коммитов и может привести к конфликтам, если другие разработчики уже скачали изменения из вашей ветки.

4. Дополнительное важное отличие между `git merge` и `git rebase` заключается в том, что `git merge` имеет различные стратегии слияния, в то время как `git rebase` не имеет никаких стратегий. 
  1. При использовании `git merge`, вы можете выбрать различные стратегии слияния, такие как `--no-ff` (не быстро-передвигаемое слияние) или `--squash` (сквош-слияние), которые позволяют вам контролировать, как именно происходит слияние и какие коммиты включаются в итоговый коммит слияния.
  2. https://blog.developer.atlassian.com/pull-request-merge-strategies-the-great-debate/ - Merge Strategies

## 4. Что показывает команда "git log -100" при "git merge" и "git rebase"? (Git)

Команда `git log -100` используется для просмотра последних 100 коммитов в истории репозитория. При использовании этой команды после выполнения операций `git merge` и `git rebase`, вы увидите различия в истории коммитов в зависимости от того, какая операция была выполнена.

`git merge`: При выполнении операции git merge, создается новый коммит, который объединяет изменения из ветки, которую вы сливаете, с вашей текущей веткой. После выполнения слияния и применения команды git log -100, вы увидите, что история коммитов будет включать коммиты из обеих веток, а также коммит слияния, который объединяет изменения.

`git rebase:` При выполнении операции git rebase, коммиты из вашей текущей ветки "перебазируются" на вершину целевой ветки. Это означает, что вместо создания нового коммита слияния, коммиты из вашей ветки будут перемещены поверх коммитов целевой ветки. После выполнения операции git log -100, вы увидите, что история коммитов будет линейной, без коммитов слияния, так как перебазирование создает новую историю коммитов без создания дополнительных коммитов слияния.

Таким образом, основное различие между git merge и git rebase в отображении истории коммитов после выполнения операций. git merge создает коммит слияния, который отображается в истории, в то время как git rebase изменяет историю коммитов, делая ее линейной и без коммитов слияния.


## 5. Какие методы решения merge-conflicts ты знаешь? (Git)

Существует несколько методов решения конфликтов слияния (merge conflicts) в Git:

1. `Ручное разрешение конфликтов`: Этот метод включает в себя ручное редактирование файлов с конфликтами слияния. Git помечает конфликтные участки в файлах специальными маркерами (<<<<<<<, =======, >>>>>>>), и вам нужно вручную выбрать, какую версию кода оставить и какую удалить.

2. `Git mergetool`: Git предоставляет возможность использовать внешние инструменты для разрешения конфликтов. Вы можете настроить Git для использования специальных программ для слияния файлов, таких как KDiff3, P4Merge, VimDiff и других, чтобы визуально разрешать конфликты.

3. `Отмена слияния`: Если вы столкнулись с трудно разрешимыми конфликтами или хотите начать слияние заново, вы можете отменить слияние с помощью команды git merge --abort.

4. `Использование режима --ours и --theirs`: С помощью опций git checkout --ours <file> и git checkout --theirs <file> вы можете выбрать, какую версию файла использовать в случае конфликта.

5. `Использование интерактивного режима rebase`: При использовании git rebase вы можете воспользоваться интерактивным режимом, чтобы выбирать, какие изменения применять и какие отклонять в процессе перебазирования.

## 6. Как создать merge-conflict? Какие шаги? (Git)

Чтобы создать конфликт слияния (merge conflict) между ветками `master` и `feature-branch1`, вы можете выполнить следующие шаги:

1. **Измените файл `file.md` в ветке `master`**:
   Внесите изменения в файл `file.md` в ветке `master`, например, добавьте строку "string4" в файл.

   ```plaintext
   string1
   string2
   string3
   string4
   ```

2. **Измените тот же файл `file.md` в ветке `feature-branch1`**:
   Теперь внесите изменения в файл `file.md` в ветке `feature-branch1`, например, добавьте строку "string5" в файл.

   ```plaintext
   string1
   string2
   string3
   string5
   ```

3. **Попытайтесь слить ветку `feature-branch1` в ветку `master`**:
   После внесения изменений в обе ветки, попытайтесь выполнить операцию слияния (merge) ветки `feature-branch1` в ветку `master` с помощью команды `git merge feature-branch1`. Git обнаружит конфликт из-за изменений, внесенных в одном и том же месте файла `file.md` в разных ветках.

После выполнения этих шагов вы должны увидеть сообщение о конфликте слияния в Git, и файл `file.md` будет содержать маркеры конфликта, указывающие на конфликтные участки кода.

## 7. Репозиторий с helm-charts. Открыли ветку. Добавили правку. Делаем MR и получаем конфликт. Как решить конфликт? (Git)

Для разрешения конфликта при слиянии веток, вам потребуется выполнить следующие шаги:

1. **Открыть конфликтный файл:**
   - Найдите файл, в котором возник конфликт при слиянии.
   - Откройте этот файл в текстовом редакторе.

2. **Понять структуру конфликта:**
   - Обычно конфликт отображается в файле с пометками `<<<<<<<`, `=======` и `>>>>>>>`. 
   - `<<<<<<<` обозначает начало изменений из вашей ветки.
   - `=======` разделяет ваш код и код из другой ветки.
   - `>>>>>>>` обозначает конец изменений из другой ветки.

3. **Решить конфликт:**
   - Проанализируйте изменения из обеих веток и решите, какие изменения следует сохранить.
   - Удалите метки `<<<<<<<`, `=======` и `>>>>>>>`, а также ненужные части кода.
   - Оставьте только те изменения, которые необходимо сохранить после слияния.

4. **Добавить изменения и завершить слияние:**
   - После разрешения конфликта сохраните изменения в файле.
   - Добавьте изменения в индекс с помощью команды `git add <file_name>`.
   - Завершите слияние с помощью команды `git merge --continue`.

