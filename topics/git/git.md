## Вопросы:
1. Отличие Git stash от Git rebase? (Git)
2. Что такое Git Cherry pick? (Git)
3. Отличие Git merge от Git rebase? (Git)
4. 

## 1. Отличие Git stash от Git rebase? (Git)

### Git stash:

https://www.atlassian.com/ru/git/tutorials/saving-changes/git-stash

Команда `git stash` позволяет на время «сдать в архив» (или отложить) изменения, сделанные в рабочей копии, чтобы вы могли применить их позже. Откладывание изменений полезно, если вам необходимо переключить контекст и вы пока не готовы к созданию коммита.

Теперь вы можете вносить изменения, создавать новые коммиты, переключаться между ветками и выполнять другие операции Git. По необходимости отложенные изменения можно будет применить позже.

Отложенные изменения сохраняются в локальном репозитории Git и не передаются на сервер при выполнении команды push.

```
$ git status
Changes to be committed:
    new file:   style.css

$ git stash
Saved working directory and index state WIP on main: 5002d47 our new homepage
HEAD is now at 5002d47 our new homepage

$ git status
On branch main
nothing to commit, working tree clean
```

Применение отложенных изменений:
```
git stash pop
```

Управление несколькими наборами отложенных изменений:
```
$ git stash list
stash@{0}: WIP on main: 5002d47 our new homepage
stash@{1}: WIP on main: 5002d47 our new homepage
stash@{2}: WIP on main: 5002d47 our new homepage
```

`git stash show` - Просмотр различий между наборами отложенных изменений

`git stash branch` - Создание ветки из отложенных изменений

`git stash drop stash@{1}` - Удаление отложенных изменений

### Git rebase:

https://www.atlassian.com/ru/git/tutorials/rewriting-history/git-rebase

Перебазирование — это процесс перемещения последовательности коммитов к новому базовому коммиту или их объединение. Операцию перебазирования удобнее всего применить и отобразить в контексте создания функциональных веток. В общих чертах процесс можно представить следующим образом:

С точки зрения содержимого перебазирование — это замена одного коммита в основании ветки на другой, в результате чего создается впечатление, что ветка получила новое начало. В процессе этой операции Git создает новые коммиты и применяет их к указанному основанию, поэтому важно понимать, что в действительности ветка всегда состоит из совершенно новых коммитов.

`Интерактивное перебазирование позволяет полностью контролировать состояние истории проекта.` Это дает разработчикам большую свободу, поскольку они могут зафиксировать засоренную историю, не отрываясь от написания кода, и очистить ее позже.

Большинство разработчиков используют интерактивное перебазирование, чтобы придать функциональной ветке аккуратность перед слиянием с основной базой кода. Они могут склеить незначительные коммиты, удалить устаревшие элементы и в целом навести порядок в ветке, прежде чем выполнить перенос в «официальную» историю проекта. Со стороны будет казаться, что для разработки функции потребовалось лишь несколько коммитов и тщательное планирование.

Оценить эффективность интерактивного перебазирования можно, взглянув на получившуюся историю ветки main. В глазах окружающих вы будете блестящим разработчиком, который внедрил новую функцию с первого раза и без лишних коммитов. `Так интерактивное перебазирование помогает поддерживать порядок в истории проекта, а также сохраняет целесообразность каждого ее элемента.`

## 2. Что такое Git Cherry pick? (Git)

https://www.atlassian.com/ru/git/tutorials/cherry-pick#

`git cherry-pick` — это полезная команда, с помощью которой можно выборочно применить коммиты Git к текущей рабочей ветке HEAD. С ее помощью можно выбрать коммит из одной ветки и применить его к другой. Команда `git cherry-pick` — это удобный способ отменить изменения. Например, если коммит попал в ветку по ошибке, вы можете переключиться на нужную ветку и выполнить перенос.

Пользоваться командой `git cherry-pick` удобно, однако это не всегда оптимально. Она может привести к дублированию коммитов, поэтому нередко разработчики предпочитают обычное слияние. Таким образом, можно сказать, что команда `git cherry-pick` — средство эффективное, но узконаправленное.

Пример использования:
Если был обнаружен баг, важно как можно скорее предоставить исправление конечным пользователям. Рассмотрим пример, когда разработчик начинает создавать новую функцию. `В ходе работы обнаруживается существующий баг`, и разработчик создает специальный коммит для его исправления. Этот `коммит можно перенести прямо в основную ветку (main)`, чтобы исправить баг, прежде чем от него пострадают другие пользователи.

## 3. Отличие Git merge от Git rebase? (Git)

`Git merge` и `Git rebase` - это два различных способа объединения изменений из одной ветки в другую. Пример визуализации обоих методов:

У нас есть две ветки: "master" и "feature-branch". Обе ветки содержат одинаковые изменения.
```
   A---B---C  master
        \
         D---E  feature-branch
```
Теперь рассмотрим, что происходит при использовании Git merge и Git rebase:

`Git merge`: При использовании Git merge, изменения из "feature-branch" объединяются с "master" с сохранением истории каждой ветки. Это создает новый коммит, который объединяет изменения обеих веток.
```
   A---B---C------F  master
        \        /
         D---E---  feature-branch
```
`Git rebase`: При использовании Git rebase, изменения из "feature-branch" переносятся поверх "master", создавая новую историю коммитов без дополнительных коммитов слияния.
```
   A---B---C  master
            \
             D'---E'  feature-branch
```
### В каких случаях нужно использовать Git merge и Git rebase:

1. Используйте Git merge, если вы хотите сохранить оригинальную историю коммитов каждой ветки и хотите, чтобы объединенная ветка содержала дополнительный коммит слияния.

2. Используйте Git rebase, если вы хотите, чтобы история коммитов была линейной и чистой, без дополнительных коммитов слияния. Это может быть полезно, когда вы работаете над функциональным изменением и хотите, чтобы история коммитов выглядела более логично.

3. Важно помнить, что при использовании Git rebase следует быть осторожным, особенно если ваш репозиторий используется другими разработчиками, так как это изменяет историю коммитов и может привести к конфликтам, если другие разработчики уже скачали изменения из вашей ветки.

4. Дополнительное важное отличие между `git merge` и `git rebase` заключается в том, что `git merge` имеет различные стратегии слияния, в то время как `git rebase` не имеет никаких стратегий. 
  1. При использовании `git merge`, вы можете выбрать различные стратегии слияния, такие как `--no-ff` (не быстро-передвигаемое слияние) или `--squash` (сквош-слияние), которые позволяют вам контролировать, как именно происходит слияние и какие коммиты включаются в итоговый коммит слияния.
  2. https://blog.developer.atlassian.com/pull-request-merge-strategies-the-great-debate/ - Merge Strategies

